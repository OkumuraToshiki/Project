/*===========================================================================
  @file   Enemy.h
  @brief  エネミー管理
  @author 奥村俊紀
  @date   2021/09/01
===========================================================================*/
#include "Enemy.h"
#include "Camera.h"
#include "FileName.hpp"
/*===========================================================================
  静的メンバ変数
===========================================================================*/
CFbxModel* EnemyClass::m_pModel = nullptr;
Vector3f   EnemyClass::m_vCenter = Vector3f(0, 0, 0);
Vector3f   EnemyClass::m_vBBox = Vector3f(0, 0, 0);
int        EnemyClass::m_nRef = 0;
/*===========================================================================
  コンストラクタ
===========================================================================*/
EnemyClass::EnemyClass(Vector3f _pos, LightClass _light)
	: m_Pos(_pos), m_Move(0, 0, 0), m_Rot(0, 0, 0), m_Size(0.5f, 0.5f, 0.5f),
	 m_Light(_light), m_box(nullptr)
{
	m_bCanJump = false;
	m_bIsHit = false;
	XMStoreFloat4x4(&m_World, XMMatrixIdentity());
	Init();
}
/*===========================================================================
  デスストラクタ
===========================================================================*/
EnemyClass::~EnemyClass()
{
}
/*===========================================================================
  初期処理
===========================================================================*/
HRESULT EnemyClass::Init()
{
	HRESULT hr = S_OK;

	// FBXファイルの読み込み
	if (m_nRef == 0) {
		SAFE_DELETE(m_pModel);
		m_pModel = new CFbxModel();
		hr = m_pModel->Init(GetDevice(), GetDeviceContext(), pszModelPath[MODEL_BOX]);
		if (SUCCEEDED(hr)) {
			m_pModel->SetCamera(CCamera::Get()->GetEye());
			m_pModel->SetLight(m_Light);

			// 境界ボックス初期化
			m_vCenter = m_pModel->GetCenter();
			m_vBBox = m_pModel->GetBBox();
			m_vBBox *= m_Size;
		}
		else {
			return hr;
		}
	}
	m_box = new BoxClass();
	hr = m_box->Init(&m_vBBox);
	if (FAILED(hr))
	{
		MessageBox(GetMainWnd(), "Boxエラー", _T("OK"), MB_OK);
	}
	m_vPosBBox = m_vCenter;
	return hr;
}
/*===========================================================================
  終了処理
===========================================================================*/
void EnemyClass::Uninit()
{
	//--- 境界ボックスの解放---
	m_box->Uninit();
	SAFE_DELETE(m_box);
	//--- FBXモデルの解放---
	--m_nRef;
	if (m_nRef == 0) {
		SAFE_DELETE(m_pModel);
	}
}
/*===========================================================================
  更新処理
===========================================================================*/
void EnemyClass::Update()
{
}
/*===========================================================================
  描画処理
===========================================================================*/
void EnemyClass::Draw()
{
	XMMATRIX mtxWorld, mtxSize, mtxRot, mtxTranslate;
	// ワールドマトリックスの初期化
	mtxWorld = XMMatrixIdentity();

	mtxSize = XMMatrixScaling(m_Size.x, m_Size.y, m_Size.z);
	mtxWorld = XMMatrixMultiply(mtxWorld, mtxSize);
	mtxRot = XMMatrixRotationRollPitchYaw(m_Rot.x, m_Rot.y, m_Rot.z);
	mtxWorld = XMMatrixMultiply(mtxWorld, mtxRot);
	// 移動を反映
	mtxTranslate = XMMatrixTranslation(m_Pos.x, m_Pos.y, m_Pos.z);
	mtxWorld = XMMatrixMultiply(mtxWorld, mtxTranslate);
	// ワールドマトリックスの設定
	XMStoreFloat4x4(&m_World, mtxWorld);

	CCamera* pCamera = CCamera::Get();
	// ---FBXファイル表示---
	SetBlendState(BS_NONE);			// アルファ処理しない
	m_pModel->Render(m_World, pCamera->GetView(),
		pCamera->GetProj(), eOpacityOnly);
	SetZWrite(false);
	SetBlendState(BS_ALPHABLEND);	// 半透明描画
	m_pModel->Render(m_World, pCamera->GetView(),
		pCamera->GetProj(), eTransparentOnly);
	SetCullMode(CULLMODE_CCW);	// 背面カリング(裏を描かない)
	//---ボックス表示---
	if (m_bIsHit) {
		XMFLOAT4 vRed(1.0f, 0.0f, 0.0f, 0.5f);
		m_box->SetColor(&vRed);
	}
	else {
		XMFLOAT4 vGreen(0.0f, 1.0f, 0.0f, 0.5f);
		m_box->SetColor(&vGreen);
	}
	m_box->Draw(m_Light);	// 境界ボックス描画
	SetCullMode(CULLMODE_CW);	// 前面カリング(表を描かない)
	SetZWrite(true);
}